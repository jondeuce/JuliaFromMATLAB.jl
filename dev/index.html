<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · MATDaemon.jl</title><script data-outdated-warner src="assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href>MATDaemon.jl</a></span></div><form class="docs-search" action="search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href>Home</a><ul class="internal"><li><a class="tocitem" href="#docstrings"><span>Docstrings</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/jondeuce/MATDaemon.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="MATDaemon.jl"><a class="docs-heading-anchor" href="#MATDaemon.jl">MATDaemon.jl</a><a id="MATDaemon.jl-1"></a><a class="docs-heading-anchor-permalink" href="#MATDaemon.jl" title="Permalink"></a></h1><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Manual installation of <code>MATDaemon.jl</code> is generally not necessary. Simply download the <a href="https://github.com/jondeuce/MATDaemon.jl/blob/v0.1.4/api/jlcall.m"><code>jlcall.m</code></a> MATLAB API function and <code>MATDaemon.jl</code> will be automatically installed into a local Julia project on first use.</p></div></div><h2 id="docstrings"><a class="docs-heading-anchor" href="#docstrings">Docstrings</a><a id="docstrings-1"></a><a class="docs-heading-anchor-permalink" href="#docstrings" title="Permalink"></a></h2><ul><li><a href="#MATDaemon.MATDaemon"><code>MATDaemon.MATDaemon</code></a></li><li><a href="#MATDaemon.JLCallOptions"><code>MATDaemon.JLCallOptions</code></a></li><li><a href="#MATDaemon.download_jlcall"><code>MATDaemon.download_jlcall</code></a></li><li><a href="#MATDaemon.init_environment-Tuple{MATDaemon.JLCallOptions}"><code>MATDaemon.init_environment</code></a></li><li><a href="#MATDaemon.jlcall-Union{Tuple{F}, Tuple{F, MATDaemon.JLCallOptions}} where F"><code>MATDaemon.jlcall</code></a></li><li><a href="#MATDaemon.jlcall_script-Tuple{}"><code>MATDaemon.jlcall_script</code></a></li><li><a href="#MATDaemon.kill-Tuple{Int64}"><code>MATDaemon.kill</code></a></li><li><a href="#MATDaemon.load_options-Tuple{String}"><code>MATDaemon.load_options</code></a></li><li><a href="#MATDaemon.matlabify-Tuple{Any}"><code>MATDaemon.matlabify</code></a></li><li><a href="#MATDaemon.save_output-Tuple{Any, MATDaemon.JLCallOptions}"><code>MATDaemon.save_output</code></a></li><li><a href="#MATDaemon.start-Tuple{Int64}"><code>MATDaemon.start</code></a></li></ul><article class="docstring"><header><a class="docstring-binding" id="MATDaemon.MATDaemon" href="#MATDaemon.MATDaemon"><code>MATDaemon.MATDaemon</code></a> — <span class="docstring-category">Module</span></header><section><div><p><strong>MATDaemon.jl</strong></p><p><em>&quot;Yes, of course duct tape works in a near-vacuum. Duct tape works anywhere. Duct tape is magic and should be worshiped.&quot; ― Andy Weir, The Martian</em></p><p><a href="https://jondeuce.github.io/MATDaemon.jl/dev"><img src="https://img.shields.io/badge/docs-dev-blue.svg" alt="dev"/></a> <a href="https://github.com/jondeuce/MATDaemon.jl/actions?query=workflow%3ACI"><img src="https://github.com/jondeuce/MATDaemon.jl/workflows/CI/badge.svg" alt="build status"/></a> <a href="http://codecov.io/github/jondeuce/MATDaemon.jl/branch/master"><img src="https://codecov.io/github/jondeuce/MATDaemon.jl/branch/master/graph/badge.svg" alt="codecov.io"/></a></p><p>Call Julia from MATLAB using a Julia daemon launched by <a href="https://github.com/dmolina/DaemonMode.jl"><code>DaemonMode.jl</code></a>.</p><p><strong>Installation</strong></p><p>Download the MATLAB function <a href="https://github.com/jondeuce/MATDaemon.jl/blob/v0.1.4/api/jlcall.m"><code>jlcall.m</code></a> from the <code>api</code> subfolder of the <code>MATDaemon.jl</code> github repository and run</p><pre><code class="language-matlab hljs">&gt;&gt; jlcall</code></pre><p>in the MATLAB console. The first time <a href="https://github.com/jondeuce/MATDaemon.jl/blob/v0.1.4/api/jlcall.m"><code>jlcall.m</code></a> is invoked in a MATLAB session:</p><ol><li>A local Julia project <code>.jlcall/Project.toml</code> will be created, if it does not already exist, to which <code>MATDaemon.jl</code> and dependencies are added. The folder <code>.jlcall</code> is stored in the same directory as the downloaded copy of <a href="https://github.com/jondeuce/MATDaemon.jl/blob/v0.1.4/api/jlcall.m"><code>jlcall.m</code></a>.</li><li>A Julia server will be started in the background using <a href="https://github.com/dmolina/DaemonMode.jl"><code>DaemonMode.jl</code></a> which loads <code>MATDaemon.jl</code>.</li></ol><p>All subsequent calls to Julia via <a href="https://github.com/jondeuce/MATDaemon.jl/blob/v0.1.4/api/jlcall.m"><code>jlcall.m</code></a> are run on the Julia server. The server will be automatically killed when MATLAB exits.</p><p><strong>Quickstart</strong></p><p>Use the MATLAB function <a href="https://github.com/jondeuce/MATDaemon.jl/blob/v0.1.4/api/jlcall.m"><code>jlcall.m</code></a> to call Julia from MATLAB:</p><pre><code class="language-matlab hljs">&gt;&gt; jlcall(&#39;sort&#39;, {rand(2,5)}, struct(&#39;dims&#39;, int64(2)))

ans =

    0.1270    0.2785    0.6324    0.8147    0.9575
    0.0975    0.5469    0.9058    0.9134    0.9649</code></pre><p>The positional arguments passed to <a href="https://github.com/jondeuce/MATDaemon.jl/blob/v0.1.4/api/jlcall.m"><code>jlcall.m</code></a> are:</p><ol><li>The Julia function to call, given as a MATLAB <code>char</code> array. This can be any Julia expression which evaluates to a function. For example, <code>&#39;a=2; b=3; x -&gt; a*x+b&#39;</code>. For convenience, the empty string <code>&#39;&#39;</code> is interpreted as <code>&#39;(args...; kwargs...) -&gt; nothing&#39;</code>, returning <code>nothing</code> for any inputs. <strong>Note:</strong> expressions are wrapped in a <code>let</code> block and evaluated in the global scope</li><li>Positional arguments, given as a MATLAB <code>cell</code> array. For example, <code>args = {arg1, arg2, ...}</code></li><li>Keyword arguments, given as a MATLAB <code>struct</code>. For example, <code>kwargs = struct(&#39;key1&#39;, value1, &#39;key2&#39;, value2, ...)</code></li></ol><p><strong>Restarting the Julia server</strong></p><p>In the event that the Julia server reaches an undesired state, the server can be restarted by passing the <code>&#39;restart&#39;</code> flag with value <code>true</code>:</p><pre><code class="language-matlab hljs">&gt;&gt; jlcall(&#39;&#39;, &#39;restart&#39;, true) % restarts the Julia server and returns nothing</code></pre><p>Similarly, one can shutdown the Julia server without restarting it:</p><pre><code class="language-matlab hljs">&gt;&gt; jlcall(&#39;&#39;, &#39;shutdown&#39;, true) % shuts down the Julia server and returns nothing</code></pre><p><strong>Setting up the Julia environment</strong></p><p>Before calling Julia functions, it may be necessary or convenient to first set up the Julia environment. For example, one may wish to activate a local <a href="https://github.com/jondeuce/MATDaemon.jl#loading-code-from-a-local-project">project environment</a>, run <a href="https://github.com/jondeuce/MATDaemon.jl#loading-setup-code">setup scripts</a>, <a href="https://github.com/jondeuce/MATDaemon.jl#loading-setup-code">import modules</a> for later use, or set the <a href="https://github.com/jondeuce/MATDaemon.jl#julia-multithreading">number of threads</a> for running multithreaded code.</p><p>This setup can be conveniently executed at the start of your MATLAB script with a single call to <a href="https://github.com/jondeuce/MATDaemon.jl/blob/v0.1.4/api/jlcall.m"><code>jlcall.m</code></a> as follows:</p><pre><code class="language-matlab hljs">&gt;&gt; jlcall(&#39;&#39;, ...
    &#39;project&#39;, &#39;/path/to/MyProject&#39;, ... % activate a local Julia Project
    &#39;setup&#39;, &#39;/path/to/setup.jl&#39;, ... % run a setup script to load some custom Julia code
    &#39;modules&#39;, {&#39;MyProject&#39;, &#39;LinearAlgebra&#39;, &#39;Statistics&#39;}, ... % load a custom module and some modules from Base Julia
    &#39;threads&#39;, &#39;auto&#39;, ... % use the default number of Julia threads
    &#39;restart&#39;, true ... % start a fresh Julia server environment
    )</code></pre><p>See the corresponding sections below for more details about these flags.</p><p><strong>Julia multithreading</strong></p><p>The number of threads used by the Julia server can be set using the <code>&#39;threads&#39;</code> flag:</p><pre><code class="language-matlab hljs">&gt;&gt; jlcall(&#39;() -&gt; Threads.nthreads()&#39;, &#39;threads&#39;, 8, &#39;restart&#39;, true)

ans =

  int64

   8</code></pre><p>The default value for <code>&#39;threads&#39;</code> is <code>&#39;auto&#39;</code>, deferring to Julia to choose the number of threads.</p><p><strong>Note:</strong> Julia cannot change the number of threads at runtime. In order for the <code>&#39;threads&#39;</code> flag to take effect, the server must be restarted.</p><p><strong>Loading modules</strong></p><p>Julia modules can be loaded and used:</p><pre><code class="language-matlab hljs">&gt;&gt; jlcall(&#39;LinearAlgebra.norm&#39;, {[3.0; 4.0]}, &#39;modules&#39;, {&#39;LinearAlgebra&#39;})

ans =

     5</code></pre><p><strong>Note:</strong> modules are loaded using <code>import</code>, not <code>using</code>. Module symbols must therefore be fully qualified, e.g. <code>LinearAlgebra.norm</code> in the above example as opposed to <code>norm</code>.</p><p><strong>Persistent environments</strong></p><p>By default, previously loaded Julia code is available on subsequent calls to <a href="https://github.com/jondeuce/MATDaemon.jl/blob/v0.1.4/api/jlcall.m"><code>jlcall.m</code></a>. For example, following the <a href="https://github.com/jondeuce/MATDaemon.jl#loading-modules">above call</a> to <code>LinearAlgebra.norm</code>, the <code>LinearAlgebra.det</code> function can be called without loading <code>LinearAlgebra</code> again:</p><pre><code class="language-matlab hljs">&gt;&gt; jlcall(&#39;LinearAlgebra.det&#39;, {[1.0 2.0; 3.0 4.0]})

ans =

    -2</code></pre><p><strong>Unique environments</strong></p><p>Set the <code>&#39;shared&#39;</code> flag to <code>false</code> in order to evaluate each Julia call in a separate namespace on the Julia server:</p><pre><code class="language-matlab hljs">% Restart the server, setting &#39;shared&#39; to false
&gt;&gt; jlcall(&#39;LinearAlgebra.norm&#39;, {[3.0; 4.0]}, &#39;modules&#39;, {&#39;LinearAlgebra&#39;}, &#39;restart&#39;, true, &#39;shared&#39;, false)

ans =

     5

% This call now errors, despite the above command loading the LinearAlgebra module, as LinearAlgebra.norm is evaluated in a new namespace
&gt;&gt; jlcall(&#39;LinearAlgebra.norm&#39;, {[3.0; 4.0]}, &#39;shared&#39;, false)
ERROR: LoadError: UndefVarError: LinearAlgebra not defined
Stacktrace:
 ...</code></pre><p><strong>Unique Julia instances</strong></p><p>Instead of running Julia code on a persistent Julia server, unique Julia instances can be launched for each call to <a href="https://github.com/jondeuce/MATDaemon.jl/blob/v0.1.4/api/jlcall.m"><code>jlcall.m</code></a> by passing the <code>&#39;server&#39;</code> flag with value <code>false</code>.</p><p><strong>Note:</strong> this may cause significant overhead when repeatedly calling <a href="https://github.com/jondeuce/MATDaemon.jl/blob/v0.1.4/api/jlcall.m"><code>jlcall.m</code></a> due to Julia package precompilation and loading:</p><pre><code class="language-matlab hljs">&gt;&gt; tic; jlcall(&#39;x -&gt; sum(abs2, x)&#39;, {1:5}, &#39;server&#39;, false); toc
Elapsed time is 4.181178 seconds. % call unique Julia instance

&gt;&gt; tic; jlcall(&#39;x -&gt; sum(abs2, x)&#39;, {1:5}, &#39;restart&#39;, true); toc
Elapsed time is 5.046929 seconds. % re-initialize Julia server

&gt;&gt; tic; jlcall(&#39;x -&gt; sum(abs2, x)&#39;, {1:5}); toc
Elapsed time is 0.267088 seconds. % call server; significantly faster</code></pre><p><strong>Loading code from a local project</strong></p><p>Code from a <a href="https://pkgdocs.julialang.org/v1/environments/">local Julia project</a> can be loaded and called:</p><pre><code class="language-matlab hljs">&gt;&gt; jlcall(&#39;MyProject.my_function&#39;, args, kwargs, ...
    &#39;project&#39;, &#39;/path/to/MyProject&#39;, ...
    &#39;modules&#39;, {&#39;MyProject&#39;})</code></pre><p><strong>Note:</strong> the string passed via the <code>&#39;project&#39;</code> flag is simply forwarded to <code>Pkg.activate</code>; it is the user&#39;s responsibility to ensure that the project&#39;s dependencies have been installed.</p><p><strong>Loading setup code</strong></p><p>Julia functions may require or return types which cannot be directly passed from or loaded into MATLAB. For example, suppose one would like to query <code>Base.VERSION</code>. Naively calling <code>jlcall(&#39;() -&gt; Base.VERSION&#39;)</code> would fail, as <code>typeof(Base.VERSION)</code> is not a <code>String</code> but a <code>VersionNumber</code>.</p><p>One possible remedy is to define a wrapper function in a Julia script:</p><pre><code class="language-julia hljs"># setup.jl
julia_version() = string(Base.VERSION)</code></pre><p>Then, use the <code>&#39;setup&#39;</code> flag to pass the above script to <a href="https://github.com/jondeuce/MATDaemon.jl/blob/v0.1.4/api/jlcall.m"><code>jlcall.m</code></a>:</p><pre><code class="language-matlab hljs">&gt;&gt; jlcall(&#39;julia_version&#39;, &#39;setup&#39;, &#39;/path/to/setup.jl&#39;)

ans =

    &#39;1.6.1&#39;</code></pre><p>In this case, <code>jlcall(&#39;() -&gt; string(Base.VERSION)&#39;)</code> would work just as well. In general, however, interfacing with complex Julia libraries using MATLAB types may be nontrivial, and the <code>&#39;setup&#39;</code> flag allows for the execution of arbitrary setup code.</p><p><strong>Note:</strong> the setup script is loaded into the global scope using <code>include</code>; when using <a href="https://github.com/jondeuce/MATDaemon.jl#persistent-environments">persistent environments</a>, symbols defined in the setup script will be available on subsequent calls to <a href="https://github.com/jondeuce/MATDaemon.jl/blob/v0.1.4/api/jlcall.m"><code>jlcall.m</code></a>.</p><p><strong>Handling Julia outputs</strong></p><p>Output(s) from Julia are returned using the MATLAB <code>cell</code> array <a href="https://www.mathworks.com/help/matlab/ref/varargout.html"><code>varargout</code></a>, MATLAB&#39;s variable-length list of output arguments. A helper function <code>MATDaemon.matlabify</code> is used to convert Julia values into MATLAB-compatible values. Specifically, the following rules are used to populate <code>varargout</code> with the Julia output <code>y</code>:</p><ol><li>If <code>y::Nothing</code>, then <code>varargout = {}</code> and no outputs are returned to MATLAB</li><li>If <code>y::Tuple</code>, then <code>length(y)</code> outputs are returned, with <code>varargout{i}</code> given by <code>matlabify(y[i])</code></li><li>Otherwise, one output is returned with <code>varargout{1}</code> given by <code>matlabify(y)</code></li></ol><p>The following <code>matlabify</code> methods are defined by default:</p><pre><code class="language-julia hljs">matlabify(x) = x # default fallback
matlabify(::Union{Nothing, Missing}) = zeros(0,0) # equivalent to MATLAB&#39;s []
matlabify(x::Symbol) = string(x)
matlabify(xs::Tuple) = Any[matlabify(x) for x in xs] # matlabify values
matlabify(xs::Union{&lt;:AbstractDict, &lt;:NamedTuple, &lt;:Base.Iterators.Pairs}) = Dict{String, Any}(string(k) =&gt; matlabify(v) for (k, v) in pairs(xs)) # convert keys to strings and matlabify values</code></pre><p><strong>Note:</strong> MATLAB <code>cell</code> and <code>struct</code> types correspond to <code>Array{Any}</code> and <code>Dict{String, Any}</code> in Julia.</p><p>Conversion via <code>matlabify</code> can easily be extended to additional types. Returning to the example from the <a href="https://github.com/jondeuce/MATDaemon.jl#loading-setup-code">above section</a>, we can define a <code>matlabify</code> method for <code>Base.VersionNumber</code>:</p><pre><code class="language-julia hljs"># setup.jl
MATDaemon.matlabify(v::Base.VersionNumber) = string(v)</code></pre><p>Now, the return type will be automatically converted:</p><pre><code class="language-matlab hljs">&gt;&gt; jlcall(&#39;() -&gt; Base.VERSION&#39;, &#39;setup&#39;, &#39;/path/to/setup.jl&#39;)

ans =

    &#39;1.6.1&#39;</code></pre><p><strong>Troubleshooting</strong></p><p>In case the Julia server gets into a bad state, the following troubleshooting tips may be helpful:</p><ul><li>Try restarting the server: <code>jlcall(&#39;&#39;, &#39;restart&#39;, true)</code></li><li>Enable debug mode for verbose logging: <code>jlcall(&#39;&#39;, &#39;debug&#39;, true)</code></li><li>Call Julia directly instead of calling the server: <code>jlcall(&#39;&#39;, &#39;server&#39;, false)</code><ul><li>This will be slower, since each call to <a href="https://github.com/jondeuce/MATDaemon.jl/blob/v0.1.4/api/jlcall.m"><code>jlcall.m</code></a> will start a new Julia instance, but it may <a href="https://github.com/jondeuce/MATDaemon.jl/issues/9#issuecomment-1761710048">fix server issues on Windows</a></li></ul></li><li>Update the <code>MATDaemon.jl</code> Julia project environment (note: this will restart the server): <code>jlcall(&#39;&#39;, &#39;update&#39;, true)</code></li><li>Reinstall the <code>MATDaemon.jl</code> workspace folder (note: this will restart the server): <code>jlcall(&#39;&#39;, &#39;reinstall&#39;, true)</code><ul><li>By default, the workspace folder is named <code>.jlcall</code> and is stored in the same directory as <a href="https://github.com/jondeuce/MATDaemon.jl/blob/v0.1.4/api/jlcall.m"><code>jlcall.m</code></a></li><li>The <code>&#39;reinstall&#39;</code> flag deletes the workspace folder, forcing <code>MATDaemon.jl</code> to be reinstalled; you can also delete it manually</li></ul></li></ul><p><strong>Performance</strong></p><p>MATLAB inputs and Julia ouputs are passed back and forth between MATLAB and the <code>DaemonMode.jl</code> server by writing to temporary <code>.mat</code> files. The location of these files can be configured with the <code>&#39;infile&#39;</code> and <code>&#39;outfile&#39;</code> flags, respectively. Pointing these files to a ram-backed file system is recommended when possible (for example, the <code>/tmp</code> folder on Linux is usually ram-backed), as read/write speed will likely improve. This is now the default; <code>&#39;infile&#39;</code> and <code>&#39;outfile&#39;</code> are created via the MATLAB <code>tempname</code> function (thanks to @mauro3 for this tip).</p><p>Nevertheless, this naturally leads to some overhead when calling Julia, particularly when the MATLAB inputs and/or Julia outputs have large memory footprints. It is therefore not recommended to use <a href="https://github.com/jondeuce/MATDaemon.jl/blob/v0.1.4/api/jlcall.m"><code>jlcall.m</code></a> in performance critical loops.</p><p><strong>MATLAB and Julia version compatibility</strong></p><p>This package has been tested on a variety of MATLAB versions. However, for some versions of Julia and MATLAB, supported versions of external libraries may clash. For example, running <a href="https://github.com/jondeuce/MATDaemon.jl/blob/v0.1.4/api/jlcall.m"><code>jlcall.m</code></a> using Julia v1.6.1 and MATLAB R2015b gives the following error:</p><pre><code class="language-matlab hljs">&gt;&gt; jlcall

ERROR: Unable to load dependent library ~/.local/julia-1.6.1/bin/../lib/julia/libjulia-internal.so.1

Message: /usr/local/MATLAB/R2015b/sys/os/glnxa64/libstdc++.so.6: version `GLIBCXX_3.4.20&#39; not found (required by ~/.local/julia-1.6.1/bin/../lib/julia/libjulia-internal.so.1)</code></pre><p>This error results due to a clash of supported <code>libstdc++</code> versions, and does not occur when using e.g. Julia v1.5.4 with MATLAB R2015b, or Julia v1.6.1 with MATLAB R2020b.</p><p>If you encounter this issue, see the <a href="https://github.com/JuliaLang/julia/blob/master/doc/build/build.md#required-build-tools-and-external-libraries"><code>Julia</code></a> and <a href="https://www.mathworks.com/support/requirements/supported-compilers.html"><code>MATLAB</code></a> documentation for information on mutually supported external libraries.</p><p><strong>About this package</strong></p><p>This repository contains utilities for parsing and running Julia code, passing MATLAB arguments to Julia, and retrieving Julia outputs from MATLAB.</p><p>The workhorse behind <code>MATDaemon.jl</code> and <a href="https://github.com/jondeuce/MATDaemon.jl/blob/v0.1.4/api/jlcall.m"><code>jlcall.m</code></a> is <a href="https://github.com/dmolina/DaemonMode.jl"><code>DaemonMode.jl</code></a> which is used to start a persistent Julia server in the background.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/MATDaemon.jl/blob/13df503df6b05d3bbdc662b32c24dfaa2a6d4d29/src/MATDaemon.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MATDaemon.JLCallOptions" href="#MATDaemon.JLCallOptions"><code>MATDaemon.JLCallOptions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">JLCallOptions(; kwargs...)</code></pre><p>Julia struct for storing <a href="https://github.com/jondeuce/MATDaemon.jl/blob/v0.1.4/api/jlcall.m"><code>jlcall.m</code></a> input parser results.</p><p>Struct fields/keyword arguments for constructor:</p><ul><li><p><code>f::String</code>: User function to be parsed and evaluated</p></li><li><p><code>infile::String</code>: MATLAB <code>.mat</code> file containing positional and keyword arguments for calling <code>f</code></p></li><li><p><code>outfile::String</code>: MATLAB <code>.mat</code> file for writing outputs of <code>f</code> into</p></li><li><p><code>runtime::String</code>: Julia runtime binary location</p></li><li><p><code>project::String</code>: Julia project to activate before calling <code>f</code></p></li><li><p><code>threads::Int64</code>: Number of Julia threads</p></li><li><p><code>setup::String</code>: Julia setup script to include before defining and calling the user function</p></li><li><p><code>nofun::Bool</code>: Treat <code>f</code> as a generic Julia expression, not a function: evaluate <code>f</code> and return <code>nothing</code></p></li><li><p><code>modules::Vector{Any}</code>: Julia modules to import before defining and calling the user function</p></li><li><p><code>cwd::String</code>: Current working directory. Change path to this directory before loading code</p></li><li><p><code>workspace::String</code>: MATDaemon workspace. Local Julia project and temporary files for communication with MATLAB are stored here</p></li><li><p><code>server::Bool</code>: Start Julia instance on a local server using <code>DaemonMode.jl</code></p></li><li><p><code>port::Int64</code>: Port to start Julia server on</p></li><li><p><code>shared::Bool</code>: Julia code is loaded into a persistent server environment if true. Otherwise, load code in unique namespace</p></li><li><p><code>restart::Bool</code>: Restart the Julia server before loading code</p></li><li><p><code>revise::Bool</code>: Enable Revise on the Julia server</p></li><li><p><code>shutdown::Bool</code>: Shut down the julia server and return</p></li><li><p><code>gc::Bool</code>: Garbage collect temporary files after each call</p></li><li><p><code>debug::Bool</code>: Print debugging information</p></li><li><p><code>quiet::Bool</code>: Suppress Julia I/O</p></li><li><p><code>update::Bool</code>: Update MATDaemon workspace dependencies</p></li><li><p><code>reinstall::Bool</code>: Reinstall MATDaemon workspace</p></li><li><p><code>VERSION::String</code>: Version number of jlcall.m (NOTE: for internal use only)</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/MATDaemon.jl/blob/13df503df6b05d3bbdc662b32c24dfaa2a6d4d29/src/MATDaemon.jl#L65-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MATDaemon.download_jlcall" href="#MATDaemon.download_jlcall"><code>MATDaemon.download_jlcall</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">download_jlcall(; ...) -&gt; String
download_jlcall(filename::String; latest, force) -&gt; String
</code></pre><p>Download or copy the <code>jlcall.m</code> MATLAB API function to the file <code>filename</code>.</p><p>By default, <code>jlcall.m</code> is copied into the current working directory from the <code>api</code> subfolder of the installed <code>MATDaemon.jl</code> source tree. The latest version of <code>jlcall.m</code> can instead be downloaded from GitHub by passing <code>latest = true</code>. The destination <code>filename</code> can be overwritten if it exists by passing <code>force = true</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/MATDaemon.jl/blob/13df503df6b05d3bbdc662b32c24dfaa2a6d4d29/src/MATDaemon.jl#L24-L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MATDaemon.init_environment-Tuple{MATDaemon.JLCallOptions}" href="#MATDaemon.init_environment-Tuple{MATDaemon.JLCallOptions}"><code>MATDaemon.init_environment</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">init_environment(opts::MATDaemon.JLCallOptions)
</code></pre><p>Initialize <a href="#MATDaemon.jlcall-Union{Tuple{F}, Tuple{F, MATDaemon.JLCallOptions}} where F"><code>jlcall</code></a> environment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/MATDaemon.jl/blob/13df503df6b05d3bbdc662b32c24dfaa2a6d4d29/src/MATDaemon.jl#L186-L190">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MATDaemon.jlcall-Union{Tuple{F}, Tuple{F, MATDaemon.JLCallOptions}} where F" href="#MATDaemon.jlcall-Union{Tuple{F}, Tuple{F, MATDaemon.JLCallOptions}} where F"><code>MATDaemon.jlcall</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jlcall(f, opts::MATDaemon.JLCallOptions) -&gt; Any
</code></pre><p>Run Julia function <code>f</code> using <a href="https://github.com/jondeuce/MATDaemon.jl/blob/v0.1.4/api/jlcall.m"><code>jlcall.m</code></a> input parser results <code>opts</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/MATDaemon.jl/blob/13df503df6b05d3bbdc662b32c24dfaa2a6d4d29/src/MATDaemon.jl#L228-L232">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MATDaemon.jlcall_script-Tuple{}" href="#MATDaemon.jlcall_script-Tuple{}"><code>MATDaemon.jlcall_script</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">jlcall_script() -&gt; String
</code></pre><p>Location of script for loading code, importing modules, and evaluating the function expression passed from <a href="https://github.com/jondeuce/MATDaemon.jl/blob/v0.1.4/api/jlcall.m"><code>jlcall.m</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/MATDaemon.jl/blob/13df503df6b05d3bbdc662b32c24dfaa2a6d4d29/src/MATDaemon.jl#L246-L250">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MATDaemon.kill-Tuple{Int64}" href="#MATDaemon.kill-Tuple{Int64}"><code>MATDaemon.kill</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kill(port::Int64; verbose)
</code></pre><p>Kill Julia server. If server is already killed, do nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/MATDaemon.jl/blob/13df503df6b05d3bbdc662b32c24dfaa2a6d4d29/src/MATDaemon.jl#L138-L142">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MATDaemon.load_options-Tuple{String}" href="#MATDaemon.load_options-Tuple{String}"><code>MATDaemon.load_options</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load_options(workspace::String) -&gt; MATDaemon.JLCallOptions
</code></pre><p>Load <a href="https://github.com/jondeuce/MATDaemon.jl/blob/v0.1.4/api/jlcall.m"><code>jlcall.m</code></a> input parser results from <code>workspace</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/MATDaemon.jl/blob/13df503df6b05d3bbdc662b32c24dfaa2a6d4d29/src/MATDaemon.jl#L160-L164">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MATDaemon.matlabify-Tuple{Any}" href="#MATDaemon.matlabify-Tuple{Any}"><code>MATDaemon.matlabify</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matlabify(x)</code></pre><p>Convert Julia value <code>x</code> to equivalent MATLAB representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/MATDaemon.jl/blob/13df503df6b05d3bbdc662b32c24dfaa2a6d4d29/src/MATDaemon.jl#L43-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MATDaemon.save_output-Tuple{Any, MATDaemon.JLCallOptions}" href="#MATDaemon.save_output-Tuple{Any, MATDaemon.JLCallOptions}"><code>MATDaemon.save_output</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">save_output(output, opts::MATDaemon.JLCallOptions)
</code></pre><p>Save <a href="#MATDaemon.jlcall-Union{Tuple{F}, Tuple{F, MATDaemon.JLCallOptions}} where F"><code>jlcall</code></a> output results into workspace.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/MATDaemon.jl/blob/13df503df6b05d3bbdc662b32c24dfaa2a6d4d29/src/MATDaemon.jl#L210-L214">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MATDaemon.start-Tuple{Int64}" href="#MATDaemon.start-Tuple{Int64}"><code>MATDaemon.start</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">start(port::Int64; shared, verbose)
</code></pre><p>Start Julia server.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/jondeuce/MATDaemon.jl/blob/13df503df6b05d3bbdc662b32c24dfaa2a6d4d29/src/MATDaemon.jl#L127-L131">source</a></section></article></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 4 March 2024 21:22">Monday 4 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
